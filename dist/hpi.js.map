{"version":3,"sources":["../tmp/ts/hpi.js"],"names":[],"mappings":"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","file":"hpi.js","sourcesContent":["\"use strict\";\nconst assert = require('assert');\nconst fs = require('fs');\nconst path = require('path');\nconst zlib = require('zlib');\nconst mkdirp = require('mkdirp');\nfunction constant(str) {\n    return str.charCodeAt(0) |\n        (str.charCodeAt(1) << 8) |\n        (str.charCodeAt(2) << 16) |\n        (str.charCodeAt(3) << 24);\n}\nconst temp_buffer_64k = new Buffer(65536);\nconst default_options = {\n    out: __dirname,\n    verbose: false,\n};\nlet options = default_options;\nrequire('yargs')\n    .usage('$0 <cmd> [args]')\n    .option('out', {\n    alias: 'o',\n    describe: 'Expand files into dir',\n    default: default_options.out,\n})\n    .option('verbose', {\n    alias: 'v',\n    describe: 'Verbose output',\n    default: default_options.verbose,\n})\n    .command('x [files...]', 'eXtract files', {}, extract)\n    .help('help')\n    .argv;\nfunction extract(argv) {\n    options = {\n        out: path.resolve(__dirname, (argv.out || argv.o || default_options.out)),\n        verbose: argv.v || argv.verbose || default_options.verbose,\n    };\n    for (let file of argv.files) {\n        const buffer = fs.readFileSync(path.resolve(__dirname, file));\n        hpi_extract(buffer, options);\n    }\n}\nfunction hpi_extract(buffer, { out }) {\n    console.log(out);\n    const marker = buffer.readUInt32LE(0);\n    const save_marker = buffer.readUInt32LE(4);\n    const directory_size = buffer.readUInt32LE(8);\n    const header_key = buffer.readUInt32LE(12);\n    const directory_offset = buffer.readUInt32LE(16);\n    const key = ~((header_key << 2) | (header_key >>> 6));\n    assert(marker == constant('HAPI'));\n    for (let i = directory_offset; i < buffer.length; ++i) {\n        const tkey = i ^ key;\n        buffer[i] = tkey ^ (~buffer[i]);\n    }\n    hpi_dir(buffer, directory_offset, out);\n}\nfunction hpi_dir(buffer, directory_offset, parent_name) {\n    const count = buffer.readUInt32LE(directory_offset);\n    const offset = buffer.readUInt32LE(directory_offset + 4);\n    for (let i = 0, j = offset; i < count; ++i, j += 9) {\n        const name_offset = buffer.readUInt32LE(j);\n        const data_offset = buffer.readUInt32LE(j + 4);\n        const is_dir = buffer[j + 8];\n        const name = read_asciiz(buffer, name_offset);\n        const full_name = path.join(parent_name, name);\n        if (is_dir) {\n            mkdirp.sync(full_name);\n            hpi_dir(buffer, data_offset, full_name);\n        }\n        else {\n            hpi_file(buffer, data_offset, full_name);\n        }\n    }\n}\nfunction hpi_file(buffer, offset, name) {\n    let data_offset = buffer.readUInt32LE(offset);\n    const file_size = buffer.readUInt32LE(offset + 4);\n    const compressed = buffer[offset + 8];\n    if (options.verbose)\n        console.log(`${name}`);\n    fs.writeFileSync(name, new Buffer(0));\n    if (compressed) {\n        const chunk_count = (file_size >>> 16) + (file_size % 65536 > 0 ? 1 : 0);\n        let chunk_offset = data_offset + chunk_count * 4;\n        for (let i = 0; i < chunk_count; ++i, data_offset += 4) {\n            const chunk_size = buffer.readUInt32LE(data_offset);\n            const marker = buffer.readUInt32LE(chunk_offset);\n            const unknown1 = buffer[chunk_offset + 4];\n            const compression = buffer[chunk_offset + 5];\n            const encrypted = buffer[chunk_offset + 6];\n            const compressed_size = buffer.readUInt32LE(chunk_offset + 7);\n            const decompressed_size = buffer.readUInt32LE(chunk_offset + 11);\n            const checksum = buffer.readUInt32LE(chunk_offset + 15);\n            assert(marker == constant('SQSH'));\n            const compressed_buffer = buffer.slice(chunk_offset + 19, chunk_offset + 19 + compressed_size);\n            let decompressed_buffer = compressed_buffer;\n            if (encrypted)\n                decrypt(compressed_buffer);\n            if (compression == 1) {\n                assert(decompressed_size <= temp_buffer_64k.length);\n                decompressed_buffer = temp_buffer_64k.slice(0, decompressed_size);\n                decompress(compressed_buffer, decompressed_buffer);\n            }\n            else if (compression == 2) {\n                throw new Error('zlib decompression not yet supported');\n            }\n            if (options.verbose)\n                console.log(decompressed_buffer.length);\n            fs.appendFileSync(name, decompressed_buffer);\n            chunk_offset += chunk_size;\n        }\n    }\n}\nfunction read_asciiz(buffer, offset) {\n    let end = offset;\n    while (buffer[end])\n        ++end;\n    return buffer.toString('ascii', offset, end);\n}\nfunction decrypt(buffer) {\n    for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = (buffer[i] - i) ^ i;\n    }\n}\nfunction decompress(inbuff, out) {\n    const window = new Array(4096);\n    let done = false;\n    let inptr = 0;\n    let outptr = 0;\n    let outbufptr = 1;\n    let mask = 1;\n    let tag = inbuff[inptr++];\n    while (!done) {\n        if ((mask & tag) == 0) {\n            out[outptr++] = inbuff[inptr];\n            window[outbufptr] = inbuff[inptr];\n            outbufptr = (outbufptr + 1) & 0xFFF;\n            inptr++;\n        }\n        else {\n            let count = inbuff.readUInt16LE(inptr);\n            inptr += 2;\n            let inbufptr = count >>> 4;\n            if (inbufptr == 0)\n                return outptr;\n            else {\n                count = (count & 0x0f) + 2;\n                if (count >= 0) {\n                    for (let x = 0; x < count; x++) {\n                        out[outptr++] = window[inbufptr];\n                        window[outbufptr] = window[inbufptr];\n                        inbufptr = (inbufptr + 1) & 0xFFF;\n                        outbufptr = (outbufptr + 1) & 0xFFF;\n                    }\n                }\n            }\n        }\n        mask *= 2;\n        if (mask & 0x0100) {\n            mask = 1;\n            tag = inbuff[inptr++];\n        }\n    }\n    return outptr;\n}\n//# sourceMappingURL=hpi.js.map"]}