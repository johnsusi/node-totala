{"version":3,"sources":["../tmp/ts/hpi.js"],"names":[],"mappings":"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","file":"hpi.js","sourcesContent":["\"use strict\";\nconst assert = require('assert');\n// const Buffer = require('buffer');\nconst fs = require('fs');\nconst path = require('path');\nconst zlib = require('zlib');\nconst mkdirp = require('mkdirp');\nfunction constant(str) {\n    return str.charCodeAt(0) |\n        (str.charCodeAt(1) << 8) |\n        (str.charCodeAt(2) << 16) |\n        (str.charCodeAt(3) << 24);\n}\nconst temp_buffer_64k = Buffer.alloc(65536);\nconst default_options = {\n    out: __dirname,\n    verbose: false,\n    trace: false,\n};\n// let options = default_options;\nconst options = require('yargs')\n    .usage('$0 files... [options]')\n    .option('out', {\n    alias: 'o',\n    describe: 'Expand files into dir',\n    string: true,\n    demand: true,\n})\n    .option('verbose', {\n    alias: ['v'],\n    describe: 'Verbose output',\n    default: false,\n    boolean: true,\n})\n    .option('trace', {\n    describe: 'Print stacktrace on errors',\n    default: false,\n    boolean: true,\n})\n    .help('help')\n    .argv;\noptions.out = path.resolve(process.cwd(), options.out);\nfor (let file of options._) {\n    try {\n        const buffer = fs.readFileSync(path.resolve(process.cwd(), file));\n        for (let { name, data } of hpi(buffer)) {\n            const full_name = path.resolve(options.out, name);\n            console.log(full_name);\n            mkdirp.sync(path.dirname(full_name));\n            fs.writeFileSync(full_name, data);\n        }\n    }\n    catch (err) {\n        if (options.trace)\n            console.error(err.stack);\n        else\n            console.error(err);\n    }\n}\nfunction* hpi(buffer) {\n    const marker = buffer.readUInt32LE(0);\n    const save_marker = buffer.readUInt32LE(4);\n    const directory_size = buffer.readUInt32LE(8);\n    const header_key = buffer.readUInt32LE(12);\n    const directory_offset = buffer.readUInt32LE(16);\n    assert(marker == constant('HAPI'));\n    if (header_key) {\n        const key = ~((header_key << 2) | (header_key >>> 6));\n        for (let i = directory_offset; i < buffer.length; ++i) {\n            const tkey = i ^ key;\n            buffer[i] = tkey ^ (~buffer[i]);\n        }\n    }\n    for (let entry of hpi_dir(buffer, directory_offset, ''))\n        yield entry;\n}\nexports.hpi = hpi;\nfunction* hpi_dir(buffer, directory_offset, parent_name) {\n    const count = buffer.readUInt32LE(directory_offset);\n    const offset = buffer.readUInt32LE(directory_offset + 4);\n    for (let i = 0, j = offset; i < count; ++i, j += 9) {\n        const name_offset = buffer.readUInt32LE(j);\n        const data_offset = buffer.readUInt32LE(j + 4);\n        const is_dir = buffer[j + 8];\n        const name = read_asciiz(buffer, name_offset);\n        const full_name = path.join(parent_name, name);\n        if (is_dir) {\n            for (let entry of hpi_dir(buffer, data_offset, full_name))\n                yield entry;\n        }\n        else\n            yield hpi_file(buffer, data_offset, full_name);\n    }\n}\nfunction hpi_file(buffer, offset, name) {\n    let data_offset = buffer.readUInt32LE(offset);\n    const file_size = buffer.readUInt32LE(offset + 4);\n    const compressed = buffer[offset + 8];\n    if (options.verbose)\n        console.log(`${name}`);\n    const file_buffer = Buffer.alloc(file_size);\n    let file_offset = 0;\n    // fs.writeFileSync(name, new Buffer(0));\n    if (compressed) {\n        const chunk_count = (file_size >>> 16) + (file_size % 65536 > 0 ? 1 : 0);\n        let chunk_offset = data_offset + chunk_count * 4;\n        for (let i = 0; i < chunk_count; ++i, data_offset += 4) {\n            const chunk_size = buffer.readUInt32LE(data_offset);\n            const marker = buffer.readUInt32LE(chunk_offset);\n            const unknown1 = buffer[chunk_offset + 4];\n            const compression = buffer[chunk_offset + 5];\n            const encrypted = buffer[chunk_offset + 6];\n            const compressed_size = buffer.readUInt32LE(chunk_offset + 7);\n            const decompressed_size = buffer.readUInt32LE(chunk_offset + 11);\n            const checksum = buffer.readUInt32LE(chunk_offset + 15);\n            assert(marker == constant('SQSH'));\n            const compressed_buffer = buffer.slice(chunk_offset + 19, chunk_offset + 19 + compressed_size);\n            let check = 0;\n            for (let x of compressed_buffer)\n                check = (check + x) & 0xFFFFFFFF;\n            assert(check == checksum);\n            if (encrypted)\n                decrypt(compressed_buffer);\n            if (compression == 1) {\n                decompress(compressed_buffer, file_buffer.slice(file_offset, file_offset + decompressed_size));\n            }\n            else if (compression == 2) {\n                zlib.unzipSync(compressed_buffer).copy(file_buffer, file_offset);\n            }\n            else {\n                throw new Error('unknown compression');\n            }\n            file_offset += decompressed_size;\n            chunk_offset += chunk_size;\n        }\n    }\n    else\n        throw new Error('uncompressed not yet supported');\n    return { name, data: file_buffer };\n}\nfunction read_asciiz(buffer, offset) {\n    let end = offset;\n    while (buffer[end])\n        ++end;\n    return buffer.toString('ascii', offset, end);\n}\nfunction decrypt(buffer) {\n    for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = (buffer[i] - i) ^ i;\n    }\n}\nfunction decompress(inbuff, out) {\n    const window = new Array(4096);\n    let done = false;\n    let inptr = 0;\n    let outptr = 0;\n    let outbufptr = 1;\n    let mask = 1;\n    let tag = inbuff[inptr++];\n    while (!done) {\n        if ((mask & tag) == 0) {\n            out[outptr++] = inbuff[inptr];\n            window[outbufptr] = inbuff[inptr];\n            outbufptr = (outbufptr + 1) & 0xFFF;\n            inptr++;\n        }\n        else {\n            let count = inbuff.readUInt16LE(inptr);\n            inptr += 2;\n            let inbufptr = count >>> 4;\n            if (inbufptr == 0)\n                return outptr;\n            else {\n                count = (count & 0x0f) + 2;\n                if (count >= 0) {\n                    for (let x = 0; x < count; x++) {\n                        out[outptr++] = window[inbufptr];\n                        window[outbufptr] = window[inbufptr];\n                        inbufptr = (inbufptr + 1) & 0xFFF;\n                        outbufptr = (outbufptr + 1) & 0xFFF;\n                    }\n                }\n            }\n        }\n        mask *= 2;\n        if (mask & 0x0100) {\n            mask = 1;\n            tag = inbuff[inptr++];\n        }\n    }\n    return outptr;\n}\n//# sourceMappingURL=hpi.js.map"]}